-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;
-- Database: LoanDB

-- DROP DATABASE IF EXISTS "LoanDB";

CREATE DATABASE "LoanDB"
    WITH
    OWNER = postgres
    ENCODING = 'UTF8'
    LC_COLLATE = 'Spanish_Dominican Republic.1252'
    LC_CTYPE = 'Spanish_Dominican Republic.1252'
    TABLESPACE = pg_default
    CONNECTION LIMIT = -1
    IS_TEMPLATE = False;

CREATE TABLE IF NOT EXISTS public.antecedentes_financieros
(
    id integer NOT NULL DEFAULT nextval('estados_id_seq'::regclass),
    id_solicitante integer NOT NULL,
    antecedente integer NOT NULL,
    fecha date NOT NULL,
    detalles text COLLATE pg_catalog."default",
    CONSTRAINT "AntecedentesFinancieros_pkey" PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.ciudad
(
    id integer NOT NULL DEFAULT nextval('ciudad_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ciudad_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.configuracion_criterios
(
    id integer NOT NULL DEFAULT nextval('configuracion_criterios_id_seq'::regclass),
    id_criterio integer NOT NULL,
    puntuacion integer,
    otros_detalles text COLLATE pg_catalog."default",
    rango_min integer NOT NULL,
    rango_max integer NOT NULL,
    CONSTRAINT configuracion_criterios_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.criterios_ponderados
(
    id integer NOT NULL DEFAULT nextval('criterios_ponderados_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    descripcion text COLLATE pg_catalog."default",
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT criterios_ponderados_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.direccion
(
    id integer NOT NULL DEFAULT nextval('direccion_id_seq'::regclass),
    descripcion character varying(100) COLLATE pg_catalog."default" NOT NULL,
    id_ciudad integer,
    id_provincia integer,
    id_pais character(3) COLLATE pg_catalog."default",
    CONSTRAINT direccion_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.documentacion_identidad
(
    id integer NOT NULL DEFAULT nextval('documentacion_identidad_id_seq'::regclass),
    solicitud_id integer NOT NULL,
    tipo_documento character varying(100) COLLATE pg_catalog."default" NOT NULL,
    documento_valido boolean NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    id_tipo integer NOT NULL,
    CONSTRAINT documentacion_identidad_pkey PRIMARY KEY (id),
    CONSTRAINT documentacion_identidad_tipo_documento_id_tipo_key UNIQUE (tipo_documento)
        INCLUDE(id_tipo)
);

CREATE TABLE IF NOT EXISTS public.documentos_contratos
(
    id integer NOT NULL DEFAULT nextval('documentos_contratos_id_seq'::regclass),
    id_prestamo integer,
    tipo_documento integer,
    nombre_documento character varying(100) COLLATE pg_catalog."default" NOT NULL,
    fecha_generacion date NOT NULL,
    estado_documento integer,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT documentos_contratos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.documentos_requeridos
(
    id integer NOT NULL DEFAULT nextval('documentos_requeridos_id_seq'::regclass),
    tipo_documento integer,
    descripcion_documento text COLLATE pg_catalog."default",
    requisitos_especificos text COLLATE pg_catalog."default",
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT documentos_requeridos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.estados
(
    id integer NOT NULL DEFAULT nextval('estados_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    descripcion text COLLATE pg_catalog."default",
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT estados_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.evaluacion_credito
(
    id integer NOT NULL DEFAULT nextval('evaluacion_credito_id_seq'::regclass),
    id_solicitud integer NOT NULL,
    puntuacion_total integer NOT NULL DEFAULT 0,
    puntuacion_solvencia integer DEFAULT 0,
    puntuacion_capacidad_pago integer DEFAULT 0,
    puntuacion_historial_crediticio integer DEFAULT 0,
    otros_detalles text COLLATE pg_catalog."default",
    puntuacion_criterio integer DEFAULT 0,
    fecha_creacion date NOT NULL,
    fecha_ult_modificacion date NOT NULL,
    CONSTRAINT evaluacion_credito_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.evaluacion_garantias_colaterales
(
    id integer NOT NULL DEFAULT nextval('evaluacion_garantias_colaterales_id_seq'::regclass),
    solicitud_id integer,
    garantias_colaterales_validas boolean NOT NULL DEFAULT false,
    valor_garantias numeric(10, 2) DEFAULT 0,
    calidad_garantias character varying(100) COLLATE pg_catalog."default",
    legalidad_garantias boolean NOT NULL DEFAULT false,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT evaluacion_garantias_colaterales_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.evaluacion_solvencia_capacidad
(
    id integer NOT NULL DEFAULT nextval('evaluacion_solvencia_capacidad_id_seq'::regclass),
    solicitud_id integer NOT NULL,
    ingresos numeric(10, 2) NOT NULL DEFAULT 0,
    gastos numeric(10, 2) NOT NULL DEFAULT 0,
    indice_endeudamiento numeric(10, 2) NOT NULL DEFAULT 0,
    estabilidad_laboral boolean NOT NULL DEFAULT false,
    capacidad_pago boolean NOT NULL DEFAULT false,
    otros_detalles text COLLATE pg_catalog."default",
    puntuacion_total numeric DEFAULT 0,
    CONSTRAINT evaluacion_solvencia_capacidad_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.historial_crediticio
(
    id integer NOT NULL DEFAULT nextval('historial_crediticio_id_seq'::regclass),
    id_solicitante integer NOT NULL,
    fecha date NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    estado_credito integer NOT NULL,
    puntuacion_crediticia integer DEFAULT 0,
    CONSTRAINT historial_crediticio_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.historial_solicitante
(
    id_historial integer NOT NULL,
    id_solicitud integer NOT NULL,
    CONSTRAINT historial_solicitante_pkey PRIMARY KEY (id_historial)
);

CREATE TABLE IF NOT EXISTS public.montos
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    puntuacion numeric NOT NULL,
    monto_min numeric NOT NULL,
    monto_max numeric NOT NULL,
    fecha time with time zone,
    CONSTRAINT montos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.montos_prestamos
(
    id integer NOT NULL DEFAULT nextval('montos_prestamos_id_seq'::regclass),
    id_solicitud integer NOT NULL,
    monto_maximo_aprobado numeric(10, 2) NOT NULL,
    monto_final_aprobado numeric(10, 2) NOT NULL,
    fecha_aprobacion date NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT montos_prestamos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.pagos
(
    id integer NOT NULL,
    id_prestamo integer NOT NULL,
    monto_pagado numeric NOT NULL,
    fecha_pago date NOT NULL,
    estado integer NOT NULL,
    CONSTRAINT pagos_pkey PRIMARY KEY (id_prestamo)
);

CREATE TABLE IF NOT EXISTS public.pais
(
    id character(3) COLLATE pg_catalog."default" NOT NULL,
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pais_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.prestamos
(
    id integer NOT NULL DEFAULT nextval('prestamos_id_seq'::regclass),
    id_tipo_prestamo integer NOT NULL,
    monto_prestamo numeric(10, 2) NOT NULL,
    estado integer NOT NULL,
    fecha_solicitud date NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT prestamos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.provincia
(
    id integer NOT NULL DEFAULT nextval('provincia_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT provincia_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.puntos_corte
(
    id integer NOT NULL DEFAULT nextval('puntos_corte_maximos_id_seq'::regclass),
    punto_max integer NOT NULL,
    punto_min integer NOT NULL,
    estado integer NOT NULL,
    fecha date,
    CONSTRAINT puntos_corte_maximos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.seguimiento_pagos
(
    id integer NOT NULL DEFAULT nextval('seguimiento_pagos_id_seq'::regclass),
    id_prestamo integer,
    fecha_pago date NOT NULL,
    monto_pago numeric(10, 2) NOT NULL,
    estado_pago integer,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT seguimiento_pagos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.solcitud_vs_criterio
(
    id integer NOT NULL DEFAULT nextval('solicitantes_id_seq'::regclass),
    id_solicitud integer NOT NULL,
    id_criterio integer NOT NULL,
    min boolean NOT NULL DEFAULT false,
    max boolean NOT NULL DEFAULT false,
    "noIncluir" boolean DEFAULT false,
    CONSTRAINT "Solcitud_vs_Criterio_pkey" PRIMARY KEY (id_solicitud, id_criterio, id),
    CONSTRAINT unique_solicitud_criterio UNIQUE (id_solicitud, id_criterio)
);

CREATE TABLE IF NOT EXISTS public.solcitud_vs_criterios
(
    id_solicitud integer NOT NULL,
    id_criterio integer NOT NULL,
    min boolean NOT NULL DEFAULT false,
    max boolean NOT NULL DEFAULT false,
    puntuacion boolean DEFAULT false,
    CONSTRAINT "Solcitud_vs_Criterios_pkey" PRIMARY KEY (id_solicitud, id_criterio)
);

CREATE TABLE IF NOT EXISTS public.solicitantes
(
    id integer NOT NULL DEFAULT nextval('solicitantes_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    apellido character varying(100) COLLATE pg_catalog."default" NOT NULL,
    direccion integer,
    telefono character varying(20) COLLATE pg_catalog."default",
    email character varying(100) COLLATE pg_catalog."default",
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT solicitantes_pkey PRIMARY KEY (id),
    CONSTRAINT solicitantes_email_key UNIQUE (email)
);

CREATE TABLE IF NOT EXISTS public.solicitud_v_prestamo
(
    id_solicitud integer NOT NULL,
    id_prestamo integer NOT NULL,
    estado integer NOT NULL,
    CONSTRAINT solicitud_v_prestamo_pkey PRIMARY KEY (id_solicitud, id_prestamo)
);

CREATE TABLE IF NOT EXISTS public.solicitudes_prestamos
(
    id integer NOT NULL DEFAULT nextval('solicitudes_prestamos_id_seq'::regclass),
    id_solicitante integer NOT NULL,
    fecha_solicitud date NOT NULL,
    completa_firmada boolean NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    estado integer NOT NULL DEFAULT 3,
    CONSTRAINT solicitudes_prestamos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.tasas_interes
(
    id integer NOT NULL DEFAULT nextval('tasas_interes_id_seq'::regclass),
    id_tipo_prestamo integer,
    tasa_interes_anual numeric(5, 2) NOT NULL,
    rango_monto numeric(10, 2)[] NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT tasas_interes_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.tipo_documento
(
    id integer NOT NULL DEFAULT nextval('tipo_documento_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT tipo_documento_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.tipos_prestamo
(
    id integer NOT NULL DEFAULT nextval('tipos_prestamo_id_seq'::regclass),
    nombre character varying(100) COLLATE pg_catalog."default" NOT NULL,
    descripcion text COLLATE pg_catalog."default",
    tasas_interes numeric,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT tipos_prestamo_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.verificaciones_credito
(
    id integer NOT NULL DEFAULT nextval('verificaciones_credito_id_seq'::regclass),
    solicitud_id integer,
    verificacion_valida boolean NOT NULL,
    otros_detalles text COLLATE pg_catalog."default",
    CONSTRAINT verificaciones_credito_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS public.antecedentes_financieros
    ADD CONSTRAINT "AntecedentesFinancieros_estado_fkey" FOREIGN KEY (antecedente)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.antecedentes_financieros
    ADD CONSTRAINT "AntecedentesFinancieros_id_solicitante_fkey" FOREIGN KEY (id_solicitante)
    REFERENCES public.solicitantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.direccion
    ADD CONSTRAINT direccion_id_ciudad_fkey FOREIGN KEY (id_ciudad)
    REFERENCES public.ciudad (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.direccion
    ADD CONSTRAINT direccion_id_pais_fkey FOREIGN KEY (id_pais)
    REFERENCES public.pais (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.direccion
    ADD CONSTRAINT direccion_id_provincia_fkey FOREIGN KEY (id_provincia)
    REFERENCES public.provincia (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.documentacion_identidad
    ADD CONSTRAINT documentacion_identidad_solicitud_id_fkey FOREIGN KEY (solicitud_id)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.documentos_contratos
    ADD CONSTRAINT documentos_contratos_estado_documento_fkey FOREIGN KEY (estado_documento)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.documentos_contratos
    ADD CONSTRAINT documentos_contratos_id_prestamo_fkey FOREIGN KEY (id_prestamo)
    REFERENCES public.montos_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.documentos_contratos
    ADD CONSTRAINT documentos_contratos_tipo_documento_fkey FOREIGN KEY (tipo_documento)
    REFERENCES public.tipo_documento (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.documentos_requeridos
    ADD CONSTRAINT documentos_requeridos_tipo_documento_fkey FOREIGN KEY (tipo_documento)
    REFERENCES public.tipo_documento (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.evaluacion_credito
    ADD CONSTRAINT evaluacion_credito_id_solicitud_fkey FOREIGN KEY (id_solicitud)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.evaluacion_garantias_colaterales
    ADD CONSTRAINT evaluacion_garantias_colaterales_solicitud_id_fkey FOREIGN KEY (solicitud_id)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.evaluacion_solvencia_capacidad
    ADD CONSTRAINT evaluacion_solvencia_capacidad_solicitud_id_fkey FOREIGN KEY (solicitud_id)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.historial_crediticio
    ADD CONSTRAINT historial_crediticio_estado_credito_fkey FOREIGN KEY (estado_credito)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.historial_crediticio
    ADD CONSTRAINT historial_crediticio_id_solicitante_fkey FOREIGN KEY (id_solicitante)
    REFERENCES public.solicitantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.historial_solicitante
    ADD CONSTRAINT historial_solicitante_id_historial_fkey FOREIGN KEY (id_historial)
    REFERENCES public.historial_crediticio (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS historial_solicitante_pkey
    ON public.historial_solicitante(id_historial);


ALTER TABLE IF EXISTS public.historial_solicitante
    ADD CONSTRAINT historial_solicitante_id_solicitud_fkey FOREIGN KEY (id_solicitud)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.montos_prestamos
    ADD CONSTRAINT montos_prestamos_id_solicitud_fkey FOREIGN KEY (id_solicitud)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.pagos
    ADD CONSTRAINT pagos_estado_fkey FOREIGN KEY (estado)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.pagos
    ADD CONSTRAINT pagos_id_prestamo_fkey FOREIGN KEY (id_prestamo)
    REFERENCES public.prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS pagos_pkey
    ON public.pagos(id_prestamo);


ALTER TABLE IF EXISTS public.prestamos
    ADD CONSTRAINT prestamos_estado_fkey FOREIGN KEY (estado)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.prestamos
    ADD CONSTRAINT prestamos_id_tipo_prestamo_fkey FOREIGN KEY (id_tipo_prestamo)
    REFERENCES public.tipos_prestamo (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.puntos_corte
    ADD CONSTRAINT puntos_corte_estado_fkey FOREIGN KEY (estado)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.seguimiento_pagos
    ADD CONSTRAINT seguimiento_pagos_estado_pago_fkey FOREIGN KEY (estado_pago)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.seguimiento_pagos
    ADD CONSTRAINT seguimiento_pagos_id_prestamo_fkey FOREIGN KEY (id_prestamo)
    REFERENCES public.montos_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solcitud_vs_criterio
    ADD CONSTRAINT "Solcitud_vs_Criterio_id_criterio_fkey" FOREIGN KEY (id_criterio)
    REFERENCES public.criterios_ponderados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solcitud_vs_criterio
    ADD CONSTRAINT "Solcitud_vs_Criterio_id_solicitud_fkey" FOREIGN KEY (id_solicitud)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solcitud_vs_criterios
    ADD CONSTRAINT "Solcitud_vs_Criterios_id_criterio_fkey" FOREIGN KEY (id_criterio)
    REFERENCES public.criterios_ponderados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solcitud_vs_criterios
    ADD CONSTRAINT "Solcitud_vs_Criterios_id_solicitud_fkey" FOREIGN KEY (id_solicitud)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solicitantes
    ADD CONSTRAINT solicitantes_direccion_fkey FOREIGN KEY (direccion)
    REFERENCES public.direccion (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solicitud_v_prestamo
    ADD CONSTRAINT solicitud_v_prestamo_estado_fkey FOREIGN KEY (estado)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.solicitud_v_prestamo
    ADD CONSTRAINT solicitud_v_prestamo_id_prestamo_fkey FOREIGN KEY (id_prestamo)
    REFERENCES public.prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.solicitud_v_prestamo
    ADD CONSTRAINT solicitud_v_prestamo_id_solicitud_fkey FOREIGN KEY (id_solicitud)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solicitudes_prestamos
    ADD CONSTRAINT solicitudes_prestamos_estado_fkey FOREIGN KEY (estado)
    REFERENCES public.estados (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    NOT VALID;


ALTER TABLE IF EXISTS public.solicitudes_prestamos
    ADD CONSTRAINT solicitudes_prestamos_id_solicitsante_fkey FOREIGN KEY (id_solicitante)
    REFERENCES public.solicitantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.tasas_interes
    ADD CONSTRAINT tasas_interes_id_tipo_prestamo_fkey FOREIGN KEY (id_tipo_prestamo)
    REFERENCES public.tipos_prestamo (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.verificaciones_credito
    ADD CONSTRAINT verificaciones_credito_solicitud_id_fkey FOREIGN KEY (solicitud_id)
    REFERENCES public.solicitudes_prestamos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
-- PROCEDURE: public.procesorecepcionyverificacion(integer, integer, numeric)

-- DROP PROCEDURE IF EXISTS public.procesorecepcionyverificacion(integer, integer, numeric);

CREATE OR REPLACE PROCEDURE public.procesorecepcionyverificacion(
	IN p_cliente_id integer,
	IN p_tipo_id integer,
	IN p_monto numeric,
	OUT p_solicitud_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
     v_solicitud_id integer;
 v_prestamo_id integer;
 v_historial_crediticio integer;
v_antecedentes_financieros integer;
BEGIN
     -- Paso 1: Recepción de Solicitud
    INSERT INTO solicitudes_prestamos (id_solicitante, fecha_solicitud, completa_firmada)
    VALUES (p_cliente_id, CURRENT_DATE, FALSE) RETURNING id INTO v_solicitud_id;

    -- Crear el préstamo
    INSERT INTO Prestamos (id_tipo_prestamo, monto_prestamo, estado, fecha_solicitud)
    VALUES (p_tipo_id, p_monto, 1, CURRENT_DATE) RETURNING id INTO v_prestamo_id;

    INSERT INTO solicitud_v_prestamo (id_solicitud, id_prestamo, estado) VALUES (v_solicitud_id, v_prestamo_id, 3);
    
    -- Verificación de la Solicitud
    IF p_monto <= 0 THEN
        RAISE EXCEPTION 'Monto de solicitud inválido';
    END IF;

    -- Validar historial crediticio del cliente
   SELECT estado_credito INTO v_historial_crediticio
    FROM historial_crediticio
    WHERE id_solicitante = p_cliente_id
	ORDER BY fecha DESC
    LIMIT 1;

    IF v_historial_crediticio IS NULL THEN
        v_historial_crediticio := 13;
    END IF;

    -- Validar antecedentes financieros del cliente
  SELECT antecedente INTO v_antecedentes_financieros
    FROM antecedentes_financieros
    WHERE id_solicitante = p_cliente_id
	ORDER BY fecha DESC
    LIMIT 1;

    IF v_antecedentes_financieros IS NULL THEN
        v_antecedentes_financieros := 14;
    END IF;

    -- Registrar detalles de la solicitud (si es necesario)

    -- Insertar registros en historial crediticio y antecedentes financieros
   INSERT INTO historial_crediticio (id_solicitante,fecha, estado_credito,puntuacion_crediticia)
    VALUES (p_cliente_id,CURRENT_DATE, v_historial_crediticio,0);

   	 INSERT INTO antecedentes_financieros (id_solicitante, antecedente,fecha)
    VALUES (p_cliente_id, v_antecedentes_financieros,CURRENT_DATE);

    -- Más verificaciones y registros según tus necesidades

    -- Actualizar el estado de la solicitud a verificada
    UPDATE Prestamos
    SET estado = 3
    WHERE id = v_prestamo_id;

    -- Actualizar el estado de solicitud_v_prestamo
    UPDATE solicitud_v_prestamo
    SET estado = 15
    WHERE id_solicitud = v_solicitud_id;
	
      p_solicitud_id := v_solicitud_id;
	
    -- (Puedes agregar más pasos aquí)
    
EXCEPTION
    -- Manejo de errores
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE EXCEPTION 'Error en el proceso de recepción y verificación';
END;
$BODY$;
ALTER PROCEDURE public.procesorecepcionyverificacion(integer, integer, numeric)
    OWNER TO postgres;
	
	
-- PROCEDURE: public.registrarcriterioponderado(character varying, text, integer, integer)

-- DROP PROCEDURE IF EXISTS public.registrarcriterioponderado(character varying, text, integer, integer);

CREATE OR REPLACE PROCEDURE public.registrarcriterioponderado(
	IN v_nombre character varying,
	IN v_descripcion text,
	IN v_rango_min integer,
	IN v_rango_max integer)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    criterio_id integer;
BEGIN
    -- Insertar en la tabla criterios_ponderados y obtener el ID resultante
    INSERT INTO criterios_ponderados (nombre, descripcion)
    VALUES (v_nombre, v_descripcion)
    RETURNING id INTO criterio_id;
    
    -- Insertar en la tabla configuracion_criterios utilizando los rangos proporcionados
    
        INSERT INTO configuracion_criterios (id_criterio, puntuacion, rango_min, rango_max)
        VALUES (criterio_id,0,v_rango_min,v_rango_max );
    
END;
$BODY$;
ALTER PROCEDURE public.registrarcriterioponderado(character varying, text, integer, integer)
    OWNER TO postgres;
	- PROCEDURE: public.registrarmontos(integer, integer, integer)

-- DROP PROCEDURE IF EXISTS public.registrarmontos(integer, integer, integer);

CREATE OR REPLACE PROCEDURE public.registrarmontos(
	IN v_puntuacion integer,
	IN v_rango_min integer,
	IN v_rango_max integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    
    -- Insertar en la tabla configuracion_criterios utilizando los rangos proporcionados  
        INSERT INTO montos (puntuacion, monto_min, monto_max,fecha)
        VALUES (v_puntuacion,v_rango_min,v_rango_max,CURRENT_DATE );
    
END;
$BODY$;
ALTER PROCEDURE public.registrarmontos(integer, integer, integer)
    OWNER TO postgres;

-- PROCEDURE: public.registrarpuntocorte(integer, integer, integer)

-- DROP PROCEDURE IF EXISTS public.registrarpuntocorte(integer, integer, integer);

CREATE OR REPLACE PROCEDURE public.registrarpuntocorte(
	IN punto_max integer,
	IN punto_min integer,
	IN estado integer)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
   

    -- Insertar el nuevo punto de corte activo
    IF estado = 1 THEN
	 -- Desactivar todos los puntos de corte existentes
    UPDATE puntos_corte SET estado = 2;     
    END IF;
	
	INSERT INTO puntos_corte (punto_max, punto_min, estado,fecha)
        VALUES (punto_max, punto_min, estado, current_DATE);
END;
$BODY$;
ALTER PROCEDURE public.registrarpuntocorte(integer, integer, integer)
    OWNER TO postgres;	
-- FUNCTION: public.calcularmontosaprobados(integer)

-- DROP FUNCTION IF EXISTS public.calcularmontosaprobados(integer);

CREATE OR REPLACE FUNCTION public.calcularmontosaprobados(
	id_solicitud_prestamo integer)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    monto_solicitado numeric;
    puntuacion_total_v integer;
    monto_min_aprobado numeric;
    monto_max_aprobado numeric;
	monto_final NUMERIC;
	punto_corte numeric;
	estado_eval integer;
BEGIN
    -- Obtener el monto solicitado
	SELECT p.monto_prestamo INTO monto_solicitado 
	FROM public.solicitud_v_prestamo sp 
	LEFT JOIN prestamos p  ON sp.id_prestamo = P.id
	where sp.id_solicitud =id_solicitud_prestamo;
    
    
    -- Obtener la puntuación total de la evaluación de crédito
    SELECT puntuacion_total INTO puntuacion_total_v FROM evaluacion_credito WHERE id_solicitud = id_solicitud_prestamo;
    
    -- Calcular los montos mínimo y máximo aprobados
    SELECT monto_min INTO monto_min_aprobado
    FROM montos
    WHERE puntuacion <= puntuacion_total_v
    ORDER BY puntuacion DESC
    LIMIT 1;
	
	  SELECT  monto_max INTO monto_max_aprobado
    FROM montos
    WHERE puntuacion <= puntuacion_total_v
    ORDER BY puntuacion DESC
    LIMIT 1;
	
	  -- Realizar la validación y asignación del monto final aprobado
    IF monto_solicitado >= monto_min_aprobado AND monto_solicitado <= monto_max_aprobado THEN
        monto_final := monto_solicitado;
    ELSIF monto_solicitado < monto_min_aprobado THEN
        monto_final := monto_min_aprobado;
    ELSE
        monto_final := monto_max_aprobado;
    END IF;
    
    -- Insertar los montos aprobados en la tabla montos_prestamos
    INSERT INTO montos_prestamos (id_solicitud, monto_maximo_aprobado, monto_final_aprobado, fecha_aprobacion)
    VALUES (id_solicitud_prestamo, monto_max_aprobado, monto_final, CURRENT_DATE);
	
	-- Evaluar criterios para decidir si aprobar o rechazar el préstamo
	SELECT punto_min INTO punto_corte FROM puntos_corte where estado = 1;
    IF puntuacion_total_v >= punto_corte THEN
        estado_eval := 4; -- Aprobar préstamo
    ELSE
        estado_eval := 16; -- Rechazar préstamo
    END IF;

    -- Actualizar estado en la tabla de solicitudes_prestamos
    UPDATE solicitudes_prestamos
    SET estado = estado_eval
    WHERE id = id_solicitud_prestamo;

    
END;
$BODY$;

ALTER FUNCTION public.calcularmontosaprobados(integer)
    OWNER TO postgres;
-- FUNCTION: public.calcular_monto_total(numeric, numeric)

-- DROP FUNCTION IF EXISTS public.calcular_monto_total(numeric, numeric);

CREATE OR REPLACE FUNCTION public.calcular_monto_total(
	monto_maximo numeric,
	monto_final numeric)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
  RETURN monto_maximo + monto_final;
END;
$BODY$;

ALTER FUNCTION public.calcular_monto_total(numeric, numeric)
    OWNER TO postgres;
-- FUNCTION: public.calcular_puntos_totales(integer)

-- DROP FUNCTION IF EXISTS public.calcular_puntos_totales(integer);

CREATE OR REPLACE FUNCTION public.calcular_puntos_totales(
	solicitud_id integer)
    RETURNS integer
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  puntos_totales INTEGER := 0;
  cp_row RECORD;
BEGIN
  -- Obtener los criterios ponderados para la solicitud de préstamo
  FOR cp_row IN
    SELECT cp.criterio_id, cc.puntuacion
    FROM criterios_ponderados_solicitud cps
    LEFT JOIN criterios_ponderados cp ON cps.id_criterio = cp.id
    LEFT JOIN configuracion_criterios cc ON cp.id = cc.criterio_id
    WHERE cp.solicitud_id = solicitud_id
  LOOP
    -- Calcular los puntos totales
    puntos_totales := puntos_totales + cp_row.puntuacion;
  END LOOP;

  RETURN puntos_totales;
END;
$BODY$;

ALTER FUNCTION public.calcular_puntos_totales(integer)
    OWNER TO postgres;
-- FUNCTION: public.calcular_interes(numeric, numeric)

-- DROP FUNCTION IF EXISTS public.calcular_interes(numeric, numeric);

CREATE OR REPLACE FUNCTION public.calcular_interes(
	monto_prestamo numeric,
	tasa_interes_anual numeric)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
  RETURN monto_prestamo * tasa_interes_anual / 100;
END;
$BODY$;

ALTER FUNCTION public.calcular_interes(numeric, numeric)
    OWNER TO postgres;
-- FUNCTION: public.actualizar_monto_total()

-- DROP FUNCTION IF EXISTS public.actualizar_monto_total();

CREATE OR REPLACE FUNCTION public.actualizar_monto_total()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  NEW.monto_total := calcular_monto_total(NEW.monto_maximo_aprobado, NEW.monto_final_aprobado);
  RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.actualizar_monto_total()
    OWNER TO postgres;
-- FUNCTION: public.actualizarmontosaprobados()

-- DROP FUNCTION IF EXISTS public.actualizarmontosaprobados();

CREATE OR REPLACE FUNCTION public.actualizarmontosaprobados()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Llamar a la función CalcularMontosAprobados con el ID de la solicitud afectada
    PERFORM CalcularMontosAprobados(NEW.id_solicitud);
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.actualizarmontosaprobados()
    OWNER TO postgres;

-- FUNCTION: public.actualizarpuntuacionevaluacioncredito()

-- DROP FUNCTION IF EXISTS public.actualizarpuntuacionevaluacioncredito();

CREATE OR REPLACE FUNCTION public.actualizarpuntuacionevaluacioncredito()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
--    INSERT INTO evaluacion_credito (id_solicitud, puntuacion_total, puntuacion_criterio, fecha_creacion, fecha_ult_modificacion)
-- SELECT NEW.id_solicitud,
--        COALESCE((SELECT puntuacion_total FROM evaluacion_credito WHERE id_solicitud = NEW.id_solicitud), calcularpuntuacionsolicitud(NEW.id_solicitud)),
--        COALESCE((SELECT puntuacion_criterio FROM evaluacion_credito WHERE id_solicitud = NEW.id_solicitud), calcularpuntuacionsolicitud(NEW.id_solicitud)),
--        COALESCE((SELECT fecha_creacion FROM evaluacion_credito WHERE id_solicitud = NEW.id_solicitud), CURRENT_DATE),
--        CURRENT_DATE
-- WHERE NOT EXISTS (SELECT 1 FROM evaluacion_credito WHERE id_solicitud = NEW.id_solicitud);
--     RETURN NEW;
-- Verificar si ya existe una evaluación para la solicitud
    IF NOT EXISTS (SELECT 1 FROM evaluacion_credito WHERE id_solicitud = NEW.id_solicitud) THEN
        -- Si no existe, insertar una nueva evaluación
        INSERT INTO evaluacion_credito (id_solicitud, puntuacion_total, puntuacion_criterio, fecha_creacion, fecha_ult_modificacion)
        VALUES (NEW.id_solicitud, calcularpuntuacionsolicitud(NEW.id_solicitud), calcularpuntuacionsolicitud(NEW.id_solicitud), CURRENT_DATE, CURRENT_DATE);
    ELSE
        -- Si existe, actualizar la puntuación y la fecha de última modificación
        UPDATE evaluacion_credito
        SET puntuacion_total = calcularpuntuacionsolicitud(NEW.id_solicitud),
            puntuacion_criterio = calcularpuntuacionsolicitud(NEW.id_solicitud),
            fecha_ult_modificacion = CURRENT_DATE
        WHERE id_solicitud = NEW.id_solicitud;
    END IF;

    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.actualizarpuntuacionevaluacioncredito()
    OWNER TO postgres;
-- View: public.vw_criterios

-- DROP VIEW public.vw_criterios;

CREATE OR REPLACE VIEW public.vw_criterios
 AS
 SELECT c.id AS id_criterio,
    c.nombre AS nombre_criterio,
    c.descripcion AS descripcion_criterio,
    p.rango_min AS minimo,
    p.rango_max AS maximo
   FROM criterios_ponderados c
     LEFT JOIN configuracion_criterios p ON c.id = p.id_criterio;

ALTER TABLE public.vw_criterios
    OWNER TO postgres;

-- View: public.vw_informacion_solicitud

-- DROP VIEW public.vw_informacion_solicitud;

CREATE OR REPLACE VIEW public.vw_informacion_solicitud
 AS
 SELECT sp.id AS solicitud_id,
    sp.fecha_solicitud,
    sp.completa_firmada,
    s.nombre AS nombre_solicitante,
    s.apellido AS apellido_solicitante,
    s.email AS email_solicitante,
    d.descripcion AS direccion_solicitante,
    c.nombre AS ciudad_solicitante,
    pr.nombre AS provincia_solicitante,
    pais.nombre AS pais_solicitante,
    di.tipo_documento,
    di.documento_valido,
    e.puntuacion_total AS puntuacion_credito,
    g.garantias_colaterales_validas,
    g.valor_garantias,
    g.calidad_garantias,
    ec.puntuacion_total AS puntuacion_solvencia,
    ec.ingresos,
    ec.gastos,
    ec.indice_endeudamiento,
    est.nombre AS estado_solicitud
   FROM solicitudes_prestamos sp
     JOIN estados est ON sp.estado = est.id
     JOIN solicitantes s ON sp.id_solicitante = s.id
     JOIN direccion d ON s.direccion = d.id
     JOIN ciudad c ON d.id_ciudad = c.id
     JOIN provincia pr ON d.id_provincia = pr.id
     JOIN pais ON d.id_pais = pais.id
     LEFT JOIN documentacion_identidad di ON sp.id = di.solicitud_id
     LEFT JOIN evaluacion_credito e ON sp.id = e.id_solicitud
     LEFT JOIN evaluacion_garantias_colaterales g ON sp.id = g.solicitud_id
     LEFT JOIN evaluacion_solvencia_capacidad ec ON sp.id = ec.solicitud_id;

ALTER TABLE public.vw_informacion_solicitud
    OWNER TO postgres;

-- View: public.vw_montos

-- DROP VIEW public.vw_montos;

CREATE OR REPLACE VIEW public.vw_montos
 AS
 SELECT montos.id,
    montos.puntuacion,
    montos.monto_min,
    montos.monto_max,
    montos.fecha
   FROM montos;

ALTER TABLE public.vw_montos
    OWNER TO postgres;

-- View: public.vw_punto_corte

-- DROP VIEW public.vw_punto_corte;

CREATE OR REPLACE VIEW public.vw_punto_corte
 AS
 SELECT p.id,
    p.punto_max,
    p.punto_min,
    e.nombre AS estado,
    p.fecha
   FROM puntos_corte p
     LEFT JOIN estados e ON p.estado = e.id;

ALTER TABLE public.vw_punto_corte
    OWNER TO postgres;



END;